Изначально были откинуты однопоточные системы. Выбирать пришлось между Erlang, Golang и Rust.
Основным языком программирования был выбран Golang, потому что найти программистов на Erlang сложно, хотя устойчивость и горячая замена кода шли в плюс Erlang. Rust, же не смотря на формальное отсутствие состояния гонки, все-таки более подходит не для написания приложений, но драйверов и операционных систем.

Обмен сообщениями между компонентами системы происходит не на классическом RabbitMQ, а на NATS - последний показал бенчмарки на сервере который сейчас используется, 1M сообщений (+360К при кластеризации) в секунду против 40К у зайца. Да и кластеризуется он быстрее и легче чем RabbitMQ.

База данных: MySQL cluster 7.6 (MySQL server 8.0).

API - пишется на Swagger (OpenAPI 2.0). Это позволяет избежать ошибок разными программистами, генерируется чистый хорошо документированный код и документация по API. К сожалению Swagger по умолчанию использует для рутинга [gorilla/mux](https://github.com/gorilla/mux), но после генерации всего API, рутинг будет переделан на [kataras/muxie](https://github.com/kataras/muxie) - он в два раза быстрее.

Фронтенд: из Iris, Beego и Revel - выбран [Revel](https://revel.github.io/). Медленнее чем Iris, но все есть из коробки, включая интеграцию с графиками. Основную нагрузку все равно будет нести API.

Масштабирование: для уменьшения издержек Docker Swarm/Kubernetes были отставлены в сторону - все компоненты системы собраны в LXC контейнерах, пока перед которыми стоит балансер HAProxy. Идея масштабирования сводится к тому, чтобы по мере увеличения клиентов последовательно переходить на более мощные сервера с сохранением структуры контейнеров, а в последствии разнести контейнера на отдельные сервера, заменив HAProxy на NATS. Кроме классического масштабирования "железом" всегда остается возможность внутри контейнеров-обработчиков запросов к API и сайту увеличивать количество goroutine. Хотя и этот процесс, как показала практика, имеет логические ограничения.

